# -*- coding: utf-8 -*-
"""model_code 0.14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WFag2CMsjbLyzKj9QyNFty9iCK-LIVgZ
"""

!pip install matplotlib-venn
!apt-get -qq install -y libfluidsynth1

# https://pypi.python.org/pypi/libarchive
!apt-get -qq install -y libarchive-dev && pip install -U libarchive
import libarchive

from google.colab import drive

drive.mount('/content/drive')

import tensorflow as tf
from tensorflow import keras
import numpy as np
import matplotlib.image as mpimg 
from keras.preprocessing import image
from keras import models
import matplotlib.pyplot as plt
import math

import keras
from tensorflow.keras.layers import MaxPooling2D, Conv2D, Flatten, Dense, Dropout
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras.layers import GlobalAveragePooling2D, GlobalMaxPooling2D, MaxPooling2D, Reshape, Dense, multiply, Permute, Concatenate, Conv2D, Add, Activation, Lambda
from keras.activations import sigmoid
from keras import layers
from keras.preprocessing.image import ImageDataGenerator
from keras import initializers
from keras.models import Sequential

#train path
train_p = "/content/drive/MyDrive/Alzheimer_s Dataset/train"
#test path
test_p = "/content/drive/MyDrive/Alzheimer_s Dataset/test"

IMG_WIDTH, IMG_HEIGHT = (300, 300)
EPOCHS = 50
BATCH_SIZE= 16
CLASSES_NO = 2
print("EPOCHS = {}".format(EPOCHS))
print("BATCH_SIZE = {}".format(BATCH_SIZE))
print("CLASSES_NO = {}".format(CLASSES_NO))

train_datagen = ImageDataGenerator(validation_split=0.1,
                                   rescale=1./255,
                                   shear_range=0.2,
                                   zoom_range=0.2,
                                   horizontal_flip=True)

train_batches = train_datagen.flow_from_directory(directory=train_p, 
                                                  classes=['NonDemented', 'VeryMildDemented', 
                                                           'MildDemented', 'ModerateDemented'], 
                                                  target_size=(224, 224),
                                                  subset='training', 
                                                  batch_size=10)

validation_batches = train_datagen.flow_from_directory(directory=train_p, 
                                                       classes=['NonDemented', 'VeryMildDemented', 
                                                                'MildDemented', 'ModerateDemented'], 
                                                       target_size=(224, 224),
                                                       subset='validation',
                                                       batch_size=10)

train_batches = train_datagen.flow_from_directory(directory=train_p, 
                                                  classes=['NonDemented', 'VeryMildDemented', 
                                                           'MildDemented', 'ModerateDemented'], 
                                                  target_size=(224, 224),
                                                  subset='training', 
                                                  batch_size=10)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

! pip install opendatasets  --upgrade --quiet

import opendatasets as od

dataset_url = 'https://www.kaggle.com/datasets/tourist55/alzheimers-dataset-4-class-of-images/discussion'

od.download(dataset_url)

# Predict function for linear regression

def linear_regression_predict(X_test):
  Y_pred = model.predict(X_test)
  for i,j in enumerate(Y_pred):
      if(j<0.5):
          Y_pred[i]=0
      else:
          Y_pred[i]=1
  print('Predicted Values : ',Y_pred)
  print('\nShape of Y_pred : {} , Shape of Y_test : {} \n'.format(Y_pred.shape,Y_test.shape))
  return Y_pred
  

# Data Processing function which will fit, predict and score the model

def data_processor(model, model_name, X_train, Y_train, X_test, Y_test):
  model.fit(X_train, Y_train)
  score.append(round(model.score(X_test, Y_test)*100,2))
  if model_name == 'Linear Regression':
    Y_pred = linear_regression_predict(X_test)
  else:
    Y_pred = model.predict(X_test)
  conf_matrix(Y_test,Y_pred)
  print('{} model Accuracy is : {:.2f}%\n'.format(model_name,model.score(X_test, Y_test)*100))

# creating a function to plot the confusion matrix

def conf_matrix(Y_test, Y_pred_mod):
  cm = confusion_matrix(Y_test,Y_pred_mod)
  plt.figure(figsize=(8,6))
  fg = sn.heatmap(cm,annot=True,cmap='Blues')
  plt.xlabel('Predicted')
  plt.ylabel('Truth')
  return plt.show()

from torchvision.datasets import ImageFolder

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

from flask import Flask, request, jsonify
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np

app = Flask(__name__)
model = load_model('path/to/your/trained/model.h5')

@app.route('/predict', methods=['POST'])
def predict():
    # Get the file from the POST request
    file = request.files['file']

    # Read the image
    img = image.load_img(file, target_size=(224, 224))

    # Preprocess the image
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.

    # Use the model to make a prediction
    prediction = model.predict(img_array)

    # Format the prediction as a JSON response
    response = {'prediction': int(prediction[0][0])}

    return jsonify(response)

if __name__ == '__main__':
    app.run(debug=True)